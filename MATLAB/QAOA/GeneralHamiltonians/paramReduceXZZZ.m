function param = paramReduceXZZZ(param)
%paramReduceXZZZ reduce redundancy in MultiQAOA parameter representation
%   when evolution is generated by
%           e^{-i\beta  \sum_j X_j}
%           e^{-i\alpha \sum_j Z_j}
%           e^{-i\gamma \sum_{<ij>} Z_i Z_j}
%
%   param = paramReduceXZZZ(param)
%   
%       param input is assumed to be in p x 3 matrix, with columns
%       corresponding to [\gamma, \alpha, \beta]

    tol = 1e-6; % tolerance at boundaries (e.g. when angle = pi, 0, etc.)
    p = size(param,1);
    
    param = mod(param, pi);
    
    Ipi_over_2 = param > pi/2;
    param(Ipi_over_2) = param(Ipi_over_2) - pi;
    
    % now everything is [-pi/2, pi/2]
    
%     % Use time reversal symmetry to fix sign of first alpha
%     if param(1, 2) < 0 % alpha
%         param = -param;
%     end
    
    
    if param(1, 2) > pi/4 + tol
        param(1,2) = param(1,2) - pi/2;
        param(:, 3) = -param(:, 3);
    elseif param(1, 2) < -pi/4 - tol
        param(1,2) = param(1,2) + pi/2;
        param(:, 3) = -param(:, 3);
    end
    
    for q = 2:p
        delta_gamma = param(q,1) - param(q-1,1);
        if delta_gamma > pi/2 + tol
            param(q,1) = param(q,1) - pi;
        elseif delta_gamma < -pi/2 - tol
            param(q, 1) = param(q,1) + pi;
        end
        
        delta_alpha = param(q,1) - param(q-1,1);
        if delta_alpha > pi/4
            param(q,2) = param(q,2) - pi/2;
            param(q:end, 3) = -param(q:end, 3);
        elseif delta_alpha < -pi/4
            param(q,2) = param(q,2) + pi/2;
            param(q:end, 3) = -param(q:end, 3);
        end
        
        delta_beta = param(q,3)-param(q-1,3);
        if  delta_beta > pi/4
            param(q,3) = param(q,3) - pi/2;
            param(q+1:end, 2) = -param(q+1:end, 2); 
        elseif delta_beta < -pi/4
            param(q,3) = param(q,3) + pi/2;
            param(q+1:end, 2) = -param(q+1:end, 2);
        end
    end
    
    param(end, 3) = mod(param(end, 3), pi/2);
end
